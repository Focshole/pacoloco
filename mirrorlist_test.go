package main

import (
	"fmt"
	"os"
	"path"
	"testing"
	"time"

	"github.com/google/go-cmp/cmp"
)

func TestUpdateRepoMirrorlist(t *testing.T) {
	var temp = t.TempDir()
	var tmpMirrorfile = path.Join(temp, "tmpMirrorFile")

	f, err := os.Create(tmpMirrorfile)
	if err != nil {
		t.Error(err)
	}
	f.Write([]byte(`################################################################################
	################# Arch Linux mirrorlist generated by Reflector #################
	################################################################################
	
	# With:       reflector --country Germany --verbose --sort rate --save /etc/pacman.d/mirrorlist
	# When:       2020-01-10 11:51:21 GMT+7
	# From:       https://archlinux.org/mirrors/status/json/
	# Retrieved:  2020-01-10 11:51:21 GMT+7
	# Last Check: 2020-01-10 11:51:21 GMT+7
	
	 Server = http://mirror.sample.ca/archlinux/$repo/os/$arch
	Server = https://a.ab.net/archlinux/$arch/os/$repo
	Server = http://example.tld/repos/$repo/os/$arch#something # Comment
		Server =https://whatever.mirror.server.com/$repo/os/$arch
	Server= http://localhost/mirror/packages/Blackarch/$repo/os/$arch
	Server = https://tooManyTests.com/archlinux/$whatever/os/$arch #Comment
	Server = http://another.test.co.uk/archlinux/$repo/o\$s/$arch
	Server = http://ThisOneShouldNotBeIncluded.test.co.uk/archlinux/
	`))
	f.Close()
	got := parseConfig([]byte(`
cache_dir: ` + temp + `
purge_files_after: 2592000 # 3600 * 24 * 30days
download_timeout: 200
port: 9139
repos:
  archTest:
    mirrorlist: ` + tmpMirrorfile + `

`))
	config = got
	updateMirrorlists()

	want := &Config{
		CacheDir: temp,
		Port:     9139,
		Repos: map[string]Repo{
			"archTest": Repo{
				Mirrorlist: tmpMirrorfile,
				URLs: []string{`http://mirror.sample.ca/archlinux/`,
					`https://a.ab.net/archlinux/`,
					`http://example.tld/repos/`,
					`https://whatever.mirror.server.com/`,
					`http://localhost/mirror/packages/Blackarch/`,
					`https://tooManyTests.com/archlinux/`,
					`http://another.test.co.uk/archlinux/`,
				},
			},
		},
		PurgeFilesAfter: 2592000,
		DownloadTimeout: 200,
	}
	if !cmp.Equal(*got, *want) {
		t.Errorf("got %v, want %v", *got, *want)
	}
}

func TestSetupMirrorlistsTimers(t *testing.T) {
	var temp = t.TempDir()
	var tmpMirrorfile = path.Join(temp, "tmpMirrorFile")
	notInvokingRefreshTime := time.Now().Add(-(time.Duration(time.Hour))) // an hour ago
	f, err := os.Create(tmpMirrorfile)
	if err != nil {
		t.Error(err)
	}
	f.Write([]byte(`Server = http://mirror.sample.ca/archlinux/$repo/os/$arch
	Server = https://a.ab.net/archlinux/$arch/os/$repo`))
	f.Close()
	got := parseConfig([]byte(`
cache_dir: ` + temp + `
purge_files_after: 2592000 # 3600 * 24 * 30days
download_timeout: 200
port: 9139
repos:
  example:
    mirrorlist: ` + tmpMirrorfile + `
  archTest:
    mirrorlist: ` + tmpMirrorfile + `
    mirrorlist_refresh_cron: 0 0 ` + fmt.Sprint(notInvokingRefreshTime.Hour()) + ` ? * 1#1 *
`))
	config = got
	updateMirrorlists()
	// I don't know how to properly test this
	if len(setupMirrorlistsTimers()) != 1 {
		t.Error(fmt.Errorf("It should return one timer only"))
	}

	want := &Config{
		CacheDir: temp,
		Port:     9139,
		Repos: map[string]Repo{
			"archTest": Repo{
				Mirrorlist:     tmpMirrorfile,
				MirrorlistCron: `0 0 ` + fmt.Sprint(notInvokingRefreshTime.Hour()) + ` ? * 1#1 *`,
				URLs: []string{`http://mirror.sample.ca/archlinux/`,
					`https://a.ab.net/archlinux/`,
				},
			},
			"example": Repo{
				Mirrorlist: tmpMirrorfile,
				URLs: []string{`http://mirror.sample.ca/archlinux/`,
					`https://a.ab.net/archlinux/`,
				},
			},
		},
		PurgeFilesAfter: 2592000,
		DownloadTimeout: 200,
	}
	if !cmp.Equal(*got, *want) {
		t.Errorf("got %v, want %v", *got, *want)
	}
}
